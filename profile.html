<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Adventure Trakker â€” Profile</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase-config.js"></script>

  <style>
    :root{
      --text: rgba(245,245,245,0.92);
      --muted: rgba(180,180,180,0.92);
      --panel: rgba(255,255,255,0.10);
      --panel-2: rgba(255,255,255,0.07);
      --border: rgba(255,255,255,0.16);
      --shadow: 0 14px 30px rgba(0,0,0,0.30);
      --bg: #0b0b0b;
      --danger: rgba(255,120,120,0.92);
      --ok: rgba(150,255,190,0.85);
    }
    html, body{
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    a{ color: inherit; }

    body{ padding: 18px; box-sizing:border-box; }

    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      margin-bottom: 14px;
      max-width: 1100px;
      margin-left:auto; margin-right:auto;
    }
    .title{
      margin:0;
      font-weight:300;
      letter-spacing:0.06em;
      color: var(--muted);
      font-size: clamp(22px, 2.6vw, 30px);
      user-select:none;
    }
    .pill{
      display:inline-flex; align-items:center; gap:10px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: var(--shadow);
      text-decoration:none;
      font-weight: 300;
      font-size: 13px;
      color: rgba(245,245,245,0.88);
      user-select:none;
      cursor:pointer;
    }
    .pill:hover{ background: rgba(255,255,255,0.13); }

    .grid{
      display:grid;
      grid-template-columns: 380px 1fr;
      gap: 14px;
      max-width: 1100px;
      margin: 0 auto;
    }
    .panel{
      border-radius: 18px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(6px);
    }
    .panelHead{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .panelTitle{
      margin:0;
      font-weight:300;
      letter-spacing:0.05em;
      color: rgba(220,220,220,0.85);
      font-size: 14px;
    }
    .panelBody{ padding: 12px 14px 14px; background: rgba(255,255,255,0.07); }

    .hero{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.20);
      height: 160px;
      overflow:hidden;
      position: relative;
    }
    .hero img{ width:100%; height:100%; object-fit: cover; display:none; }
    .heroOverlay{
      position:absolute; inset:0;
      background: radial-gradient(ellipse at top, rgba(255,255,255,0.04), rgba(0,0,0,0) 60%),
                  radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.55) 100%);
      pointer-events:none;
    }

    .avatarRow{ display:flex; align-items:center; gap:12px; margin-top: 12px; }
    .avatar{
      width: 64px; height: 64px; border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
      box-shadow: var(--shadow);
      flex: 0 0 auto;
    }
    .avatar img{ width:100%; height:100%; object-fit: cover; display:none; }
    .avatar .initial{ font-weight:300; font-size: 24px; }

    .meta .nick{ font-size: 16px; font-weight:300; margin:0; }
    .meta .user{ font-size: 12px; font-weight:300; color: rgba(245,245,245,0.65); margin-top: 2px; }

    .row{ display:flex; flex-direction:column; gap: 8px; margin-top: 12px; }
    label{ font-size: 12px; font-weight:300; color: rgba(245,245,245,0.70); }
    input{
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.22);
      color: rgba(245,245,245,0.92);
      outline: none;
      font-weight: 300;
    }

    .btn{
      width: 100%;
      border: none;
      border-radius: 16px;
      padding: 12px 14px;
      cursor: pointer;
      color: rgba(245,245,245,0.92);
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: var(--shadow);
      font-weight: 300;
      letter-spacing: 0.02em;
      margin-top: 12px;
    }
    .btn:hover{ background: rgba(255,255,255,0.15); }

    .soft{ font-size: 12px; font-weight:300; color: rgba(245,245,245,0.60); }
    .soft.error{ color: var(--danger); }
    .soft.ok{ color: var(--ok); }

    .sectionTitle{
      margin: 12px 0 8px;
      font-weight: 300;
      letter-spacing: 0.05em;
      color: rgba(220,220,220,0.78);
      font-size: 12px;
      user-select:none;
    }

    .list{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .item{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .itemLeft{
      min-width: 0;
      display:flex;
      flex-direction:column;
      gap: 2px;
    }
    .itemName{
      font-size: 12.5px;
      font-weight:300;
      color: rgba(245,245,245,0.88);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 520px;
    }
    .itemSub{
      font-size: 11.5px;
      font-weight:300;
      color: rgba(245,245,245,0.62);
    }
    .miniActions{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;
    }
    .miniBtn{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      color: rgba(245,245,245,0.85);
      padding: 7px 10px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:300;
      font-size: 12px;
      user-select:none;
    }
    .miniBtn:hover{ background: rgba(255,255,255,0.12); }
    .miniBtn.danger{ border-color: rgba(255,120,120,0.30); color: rgba(255,150,150,0.88); }

    @media (max-width: 920px){
      .grid{ grid-template-columns: 1fr; }
      .itemName{ max-width: 100%; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <h1 class="title">Profile</h1>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <a class="pill" href="index.html">Home</a>
      <button id="signoutBtn" class="pill" type="button">Sign out</button>
    </div>
  </div>

  <div class="grid">
    <!-- YOU -->
    <div class="panel">
      <div class="panelHead">
        <h2 class="panelTitle">You</h2>
        <span class="soft" id="status"></span>
      </div>
      <div class="panelBody">
        <div class="hero">
          <img id="bgImg" alt="profile background"/>
          <div class="heroOverlay"></div>
        </div>

        <div class="avatarRow">
          <div class="avatar" id="avatarBox">
            <img id="avatarImg" alt="avatar"/>
            <div class="initial" id="avatarInitial">A</div>
          </div>
          <div class="meta">
            <p class="nick" id="nickText">â€”</p>
            <div class="user" id="userText">â€”</div>
          </div>
        </div>

        <div class="row">
          <label for="nickInput">Nickname</label>
          <input id="nickInput" placeholder="Update your nickname"/>
        </div>

        <div class="row">
          <label for="avatarFile">Update avatar (optional)</label>
          <input id="avatarFile" type="file" accept="image/*"/>
        </div>

        <div class="row">
          <label for="bgFile">Update background (optional)</label>
          <input id="bgFile" type="file" accept="image/*"/>
        </div>

        <button id="saveBtn" class="btn">Save changes</button>
      </div>
    </div>

    <!-- FRIENDS -->
    <div class="panel">
      <div class="panelHead">
        <h2 class="panelTitle">Friends</h2>
        <span class="soft" id="friendsStatus"></span>
      </div>
      <div class="panelBody">
        <div class="row" style="margin-top:0;">
          <label for="friendSearch">Add friend by username</label>
          <input id="friendSearch" placeholder="username (ex: ethan.m)" />
          <button id="sendRequestBtn" class="btn" style="margin-top:10px;">Send friend request</button>
          <div class="soft" id="searchHint" style="margin-top:8px;"></div>
        </div>

        <div class="sectionTitle">Incoming requests</div>
        <div class="list" id="incomingList"><div class="soft">Loadingâ€¦</div></div>

        <div class="sectionTitle">Outgoing requests</div>
        <div class="list" id="outgoingList"><div class="soft">Loadingâ€¦</div></div>

        <div class="sectionTitle">Friends</div>
        <div class="list" id="friendsList"><div class="soft">Loadingâ€¦</div></div>
      </div>
    </div>
  </div>

  <script>
    function hashToHue(str){
      let h = 0;
      for (let i=0;i<str.length;i++) h = (h * 31 + str.charCodeAt(i)) >>> 0;
      return h % 360;
    }
    function initialFromNickname(nickname){
      const n = String(nickname || "").trim();
      if (!n) return "?";
      const ch = n[0].toUpperCase();
      return /[A-Z0-9]/.test(ch) ? ch : "?";
    }
    function colorFromNickname(nickname){
      const hue = hashToHue(String(nickname||""));
      return `hsl(${hue} 70% 60%)`;
    }
    function esc(s){
      return String(s ?? "").replace(/[&<>"']/g, (c) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }
    function normalizeUsername(username){
      return String(username || "").trim().toLowerCase();
    }
    function isValidUsername(username){
      return /^[a-z0-9._]{3,24}$/.test(username);
    }

    const sb = window.supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);

    const statusEl = document.getElementById("status");
    const friendsStatusEl = document.getElementById("friendsStatus");

    const nickText = document.getElementById("nickText");
    const userText = document.getElementById("userText");
    const nickInput = document.getElementById("nickInput");

    const avatarImg = document.getElementById("avatarImg");
    const avatarInitial = document.getElementById("avatarInitial");
    const avatarBox = document.getElementById("avatarBox");

    const bgImg = document.getElementById("bgImg");

    const avatarFile = document.getElementById("avatarFile");
    const bgFile = document.getElementById("bgFile");

    const friendSearch = document.getElementById("friendSearch");
    const sendRequestBtn = document.getElementById("sendRequestBtn");
    const searchHint = document.getElementById("searchHint");

    const incomingList = document.getElementById("incomingList");
    const outgoingList = document.getElementById("outgoingList");
    const friendsList = document.getElementById("friendsList");

    let currentUser = null;
    let myProfile = null;

    function setStatus(el, msg, type){
      el.className = "soft" + (type ? (" " + type) : "");
      el.textContent = msg || "";
    }

    function applyAvatar(profile){
      const url = profile?.avatar_url;
      const init = profile?.avatar_initial || initialFromNickname(profile?.nickname);
      const color = profile?.avatar_color || colorFromNickname(profile?.nickname || "adventure");

      if (url){
        avatarImg.src = url;
        avatarImg.style.display = "block";
        avatarInitial.style.display = "none";
      } else {
        avatarImg.style.display = "none";
        avatarInitial.style.display = "block";
        avatarInitial.textContent = init;
        avatarInitial.style.color = color;
      }
      avatarBox.style.background = "rgba(0,0,0,0.35)";
    }

    function applyBackground(profile){
      const url = profile?.background_url;
      if (url){
        bgImg.src = url;
        bgImg.style.display = "block";
      } else {
        bgImg.style.display = "none";
      }
    }

    async function uploadToBucket(bucket, path, file){
      const { error } = await sb.storage.from(bucket).upload(path, file, { upsert:true, cacheControl:"3600" });
      if (error) throw error;
      const { data } = sb.storage.from(bucket).getPublicUrl(path);
      return data?.publicUrl || null;
    }

    function renderEmpty(listEl, msg){
      listEl.innerHTML = "";
      const d = document.createElement("div");
      d.className = "soft";
      d.textContent = msg;
      listEl.appendChild(d);
    }

    function renderRequestItem(req, otherProfile, isIncoming){
      const row = document.createElement("div");
      row.className = "item";
      const name = otherProfile?.nickname || otherProfile?.username || "Unknown";
      const uname = otherProfile?.username ? ("@" + otherProfile.username) : "";
      row.innerHTML = `
        <div class="itemLeft">
          <div class="itemName">${esc(name)} <span class="soft">${esc(uname)}</span></div>
          <div class="itemSub">${isIncoming ? "Wants to be friends" : "Pending"}</div>
        </div>
        <div class="miniActions"></div>
      `;
      const actions = row.querySelector(".miniActions");

      if (isIncoming){
        const accept = document.createElement("button");
        accept.className = "miniBtn";
        accept.textContent = "Accept";
        accept.onclick = () => acceptRequest(req);
        const decline = document.createElement("button");
        decline.className = "miniBtn danger";
        decline.textContent = "Decline";
        decline.onclick = () => declineRequest(req);
        actions.appendChild(accept);
        actions.appendChild(decline);
      } else {
        const cancel = document.createElement("button");
        cancel.className = "miniBtn danger";
        cancel.textContent = "Cancel";
        cancel.onclick = () => cancelRequest(req);
        actions.appendChild(cancel);
      }

      return row;
    }

    function renderFriendItem(friendProfile, otherId){
      const row = document.createElement("div");
      row.className = "item";
      const name = friendProfile?.nickname || friendProfile?.username || "Unknown";
      const uname = friendProfile?.username ? ("@" + friendProfile.username) : "";

      row.innerHTML = `
        <div class="itemLeft">
          <div class="itemName">${esc(name)} <span class="soft">${esc(uname)}</span></div>
          <div class="itemSub">Friend</div>
        </div>
        <div class="miniActions"></div>
      `;

      const actions = row.querySelector(".miniActions");
      const unfriend = document.createElement("button");
      unfriend.className = "miniBtn danger";
      unfriend.textContent = "Unfriend";
      unfriend.onclick = () => unfriendUser(otherId);
      actions.appendChild(unfriend);

      return row;
    }

    async function loadProfile(){
      const { data: { user } } = await sb.auth.getUser();
      if (!user){
        window.location.href = "signin.html";
        return;
      }
      currentUser = user;

      const { data, error } = await sb.from("profiles")
        .select("id, username, nickname, avatar_url, avatar_initial, avatar_color, background_url")
        .eq("id", user.id)
        .maybeSingle();

      if (error){
        setStatus(statusEl, "Unable to load profile.", "error");
        return;
      }
      if (!data){
        window.location.href = "create.html";
        return;
      }
      myProfile = data;

      nickText.textContent = data.nickname || "â€”";
      userText.textContent = "@" + (data.username || "â€”");
      nickInput.value = data.nickname || "";

      applyAvatar(data);
      applyBackground(data);
      setStatus(statusEl, "");
    }

    async function saveChanges(){
      if (!currentUser) return;

      setStatus(statusEl, "Savingâ€¦");

      const newNick = String(nickInput.value || "").trim();
      if (!newNick){
        setStatus(statusEl, "Nickname is required.", "error");
        return;
      }

      const updates = {
        nickname: newNick,
        avatar_initial: initialFromNickname(newNick),
        avatar_color: colorFromNickname(newNick),
        updated_at: new Date().toISOString()
      };

      const avatar = avatarFile.files && avatarFile.files[0];
      if (avatar){
        try{
          const ext = (avatar.name.split(".").pop() || "png").toLowerCase();
          const safeExt = ext.match(/^[a-z0-9]+$/) ? ext : "png";
          const path = `avatars/${currentUser.id}/avatar_${Date.now()}.${safeExt}`;
          updates.avatar_url = await uploadToBucket("profile-avatars", path, avatar);
        } catch (e){
          console.warn(e);
          setStatus(statusEl, "Avatar upload failed.", "error");
          return;
        }
      }

      const bg = bgFile.files && bgFile.files[0];
      if (bg){
        try{
          const ext = (bg.name.split(".").pop() || "jpg").toLowerCase();
          const safeExt = ext.match(/^[a-z0-9]+$/) ? ext : "jpg";
          const path = `backgrounds/${currentUser.id}/bg_${Date.now()}.${safeExt}`;
          updates.background_url = await uploadToBucket("profile-backgrounds", path, bg);
        } catch (e){
          console.warn(e);
          setStatus(statusEl, "Background upload failed.", "error");
          return;
        }
      }

      const { error } = await sb.from("profiles")
        .update(updates)
        .eq("id", currentUser.id);

      if (error){
        setStatus(statusEl, error.message || "Save failed.", "error");
        return;
      }

      setStatus(statusEl, "Saved.", "ok");
      await loadProfile();
      avatarFile.value = "";
      bgFile.value = "";
    }

    // FRIENDS LOGIC
    async function findProfileByUsername(username){
      const u = normalizeUsername(username);
      if (!isValidUsername(u)) return { error: "Invalid username format." };

      // Requires profiles SELECT policy that allows reading other users (see SQL note below).
      const { data, error } = await sb.from("profiles")
        .select("id, username, nickname, avatar_url")
        .eq("username", u)
        .maybeSingle();

      if (error) return { error: error.message || "Search failed." };
      if (!data) return { error: "No user found with that username." };
      return { data };
    }

    async function sendFriendRequest(){
      if (!currentUser) return;
      setStatus(friendsStatusEl, "");

      const username = friendSearch.value;
      searchHint.textContent = "";

      const res = await findProfileByUsername(username);
      if (res.error){
        searchHint.textContent = res.error;
        return;
      }
      const other = res.data;

      if (other.id === currentUser.id){
        searchHint.textContent = "Thatâ€™s you ðŸ™‚";
        return;
      }

      setStatus(friendsStatusEl, "Sendingâ€¦");

      // Create request
      const { error } = await sb.from("friend_requests").insert([{
        from_user: currentUser.id,
        to_user: other.id,
        status: "pending"
      }]);

      if (error){
        // Common cases: duplicate pending request, already friends, RLS blocked.
        setStatus(friendsStatusEl, error.message || "Could not send request.", "error");
        return;
      }

      setStatus(friendsStatusEl, "Request sent.", "ok");
      friendSearch.value = "";
      await refreshFriendsUI();
    }

    async function acceptRequest(req){
      setStatus(friendsStatusEl, "Acceptingâ€¦");
      // 1) mark request accepted
      const { error: upErr } = await sb.from("friend_requests")
        .update({ status: "accepted", updated_at: new Date().toISOString() })
        .eq("id", req.id);

      if (upErr){
        setStatus(friendsStatusEl, upErr.message || "Could not accept.", "error");
        return;
      }

      // 2) insert friendship
      const user_a = req.from_user;
      const user_b = req.to_user;

      const { error: frErr } = await sb.from("friendships").insert([{ user_a, user_b }]);
      // ignore unique violation if already inserted
      if (frErr && !String(frErr.message||"").toLowerCase().includes("duplicate")){
        // Still okay if it already exists.
        console.warn(frErr);
      }

      setStatus(friendsStatusEl, "Friends!", "ok");
      await refreshFriendsUI();
    }

    async function declineRequest(req){
      setStatus(friendsStatusEl, "Decliningâ€¦");
      const { error } = await sb.from("friend_requests")
        .update({ status: "declined", updated_at: new Date().toISOString() })
        .eq("id", req.id);

      if (error){
        setStatus(friendsStatusEl, error.message || "Could not decline.", "error");
        return;
      }
      setStatus(friendsStatusEl, "");
      await refreshFriendsUI();
    }

    async function cancelRequest(req){
      setStatus(friendsStatusEl, "Cancellingâ€¦");
      const { error } = await sb.from("friend_requests")
        .update({ status: "cancelled", updated_at: new Date().toISOString() })
        .eq("id", req.id);

      if (error){
        setStatus(friendsStatusEl, error.message || "Could not cancel.", "error");
        return;
      }
      setStatus(friendsStatusEl, "");
      await refreshFriendsUI();
    }

    async function unfriendUser(otherId){
      if (!currentUser) return;
      setStatus(friendsStatusEl, "Removingâ€¦");

      // Find the friendship row that includes both IDs and delete it.
      // We store user_low/user_high; easiest is delete where (user_low = least) AND (user_high = greatest).
      const a = currentUser.id;
      const b = otherId;
      const low = (a < b) ? a : b;
      const high = (a < b) ? b : a;

      const { error } = await sb.from("friendships")
        .delete()
        .eq("user_low", low)
        .eq("user_high", high);

      if (error){
        setStatus(friendsStatusEl, error.message || "Could not remove friend.", "error");
        return;
      }

      setStatus(friendsStatusEl, "");
      await refreshFriendsUI();
    }

    async function refreshFriendsUI(){
      if (!currentUser) return;
      setStatus(friendsStatusEl, "");

      // Incoming pending
      const { data: incoming, error: inErr } = await sb.from("friend_requests")
        .select("id, from_user, to_user, status, created_at")
        .eq("to_user", currentUser.id)
        .eq("status", "pending")
        .order("created_at", { ascending: false });

      if (inErr){
        renderEmpty(incomingList, "Unable to load.");
      } else if (!incoming?.length){
        renderEmpty(incomingList, "None.");
      } else {
        incomingList.innerHTML = "";
      }

      // Outgoing pending
      const { data: outgoing, error: outErr } = await sb.from("friend_requests")
        .select("id, from_user, to_user, status, created_at")
        .eq("from_user", currentUser.id)
        .eq("status", "pending")
        .order("created_at", { ascending: false });

      if (outErr){
        renderEmpty(outgoingList, "Unable to load.");
      } else if (!outgoing?.length){
        renderEmpty(outgoingList, "None.");
      } else {
        outgoingList.innerHTML = "";
      }

      // Friendships
      const { data: friends, error: frErr } = await sb.from("friendships")
        .select("user_low, user_high, created_at")
        .or(`user_low.eq.${currentUser.id},user_high.eq.${currentUser.id}`)
        .order("created_at", { ascending: false });

      if (frErr){
        renderEmpty(friendsList, "Unable to load.");
      } else if (!friends?.length){
        renderEmpty(friendsList, "No friends yet.");
      } else {
        friendsList.innerHTML = "";
      }

      // Collect all "other ids" to fetch profiles in one go
      const otherIds = new Set()
      ;(incoming||[]).forEach(r => otherIds.add(r.from_user));
      ;(outgoing||[]).forEach(r => otherIds.add(r.to_user));
      ;(friends||[]).forEach(f => otherIds.add(f.user_low === currentUser.id ? f.user_high : f.user_low));

      let profilesById = {};
      const ids = Array.from(otherIds);
      if (ids.length){
        const { data: profs, error: pErr } = await sb.from("profiles")
          .select("id, username, nickname, avatar_url")
          .in("id", ids);

        if (!pErr && profs){
          for (const p of profs) profilesById[p.id] = p;
        }
      }

      // Render lists
      if (incoming?.length){
        incomingList.innerHTML = "";
        for (const r of incoming){
          incomingList.appendChild(renderRequestItem(r, profilesById[r.from_user], true));
        }
      }

      if (outgoing?.length){
        outgoingList.innerHTML = "";
        for (const r of outgoing){
          outgoingList.appendChild(renderRequestItem(r, profilesById[r.to_user], false));
        }
      }

      if (friends?.length){
        friendsList.innerHTML = "";
        for (const f of friends){
          const otherId = (f.user_low === currentUser.id) ? f.user_high : f.user_low;
          friendsList.appendChild(renderFriendItem(profilesById[otherId], otherId));
        }
      }
    }

    document.getElementById("saveBtn").addEventListener("click", saveChanges);
    document.getElementById("signoutBtn").addEventListener("click", async () => {
      await sb.auth.signOut();
      window.location.href = "index.html";
    });

    sendRequestBtn.addEventListener("click", sendFriendRequest);
    friendSearch.addEventListener("keydown", (e) => {
      if (e.key === "Enter") sendFriendRequest();
    });

    (async () => {
      await loadProfile();
      await refreshFriendsUI();
    })();
  </script>
</body>
</html>
